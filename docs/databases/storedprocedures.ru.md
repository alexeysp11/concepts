# Хранимые процедуры 

## Disclaimer

Очень часто выбор того или иного архитектурного решения на реальном проекте продиктован не компетенцией конкретного программиста или архитектора ПО, а требованиями со стороны бизнеса (например, сократить время/стоимость разработки и поддержки ПО). 
Для этого могут использоваться разные подходы:
- low-code/no-code платформы.
- 

**Важно**: выбор архитектурного решения в большинстве случаев не снимает ответственность с программиста за некорректно работающий код.

## Introduction

Ситуация, когда большая часть логики находится в хранимых процедурах, может быть связана со следующими причинами:
- особенности платформы ([ссылка на пример](https://wfsys.gitbook.io/workflow-engine-syntax/workflow_engine/sql_queries/sql_query): внутри тэга `Text` предполагается писать SQL-запрос):
```XML
<SqlQuery Name="">
  <Updates>
    <Update TableName="" Type="" Parameter="" OnlyLast="" />
  </Updates>
  <Events>
    <Event Name="">
      <Parameters>
        <Parameter Name=""></Parameter>
      </Parameters>
    </Event>
  </Events>
  <Text></Text>
</SqlQuery>
```
- если система написана давно, и перенос бизнес-логики в ООП модель оказывается дороже, чем поддержание бизнес-логики в хранимых процедурах.

## Хранимые процедуры vs ORM/ООП

Хранимые процедуры увеличивают скорость работы с данными, но являются менее динамичными в плане изменения/гибкости бизнес-логики по сравнению с ORM и парадигмой ООП.

Кроме того, среди негативных сторон процедур можно отметить: 
- Сложность в документировании, в т.ч. из-за недостаточной выразительности SQL в контексте описания бизнес-логики.
- Сложность/невозможность юнит-тестирования.
- БД часто рассматривается как наименее расширяемая часть (например, в контексте бизнес-логики, как сказано выше).

[Pros and Cons of holding all the business logic in stored procedures in web application](https://softwareengineering.stackexchange.com/questions/158534/pros-and-cons-of-holding-all-the-business-logic-in-stored-procedures-in-web-appl)

## Портирование бизнес-логики из хранимых процедур 

Один из примеров удачного комбинирования хранимых процедур с ORM является, например, **получение отделов пользователя в ELMA**: 
- на уровне ORM: метод [PublicAPI.Portal.Security.User.GetUserDepartments()](https://kb.elma-bpm.com/help_api/version/3.9.0/en_US/html/M_EleWise_ELMA_API_PublicAPI_PortalApiRoot_SecurityPortalApi_UserSecurityApi_GetUserDepartments.htm):
```C#
public IEnumerable<OrganizationItem> GetUserDepartments(
	User user
)
```
- на уровне БД: `getusersdepartments()` (актуально для PostgreSQL) - возвращает [таблицу ассоциаций]().

При работе с запросами, использующими хранимые процедуры или триггеры, могут возникнуть следующие проблемы:
- Замедление процессов из-за необходимости выполнения хранимых процедур или триггеров.
- Неэффективное использование ресурсов из-за создания большого количества хранимых процедур или триггеров.
- Проблемы с обновлением и резервным копированием БД из-за необходимости учета хранимых процедур и триггеров.

