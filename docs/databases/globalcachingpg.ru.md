# Глабальное кэширование в PostgreSQL

Я хотел бы узнать про возможность изолирования данных для таблиц в БД для конкретного пользователя.
Объяню ситуацию: я работал на большом предприятии, и у нас была БД Oracle. Там очень часто использовались временные таблицы для хранения разных типов, например:

```SQL
CREATE TABLE tmp_id1 (
  id1 NUMBER
);
CREATE TABLE tmp_id2 (
  id1 NUMBER,
  id2 NUMBER
);
CREATE TABLE tmp_id3 (
  id1 NUMBER,
  id2 NUMBER,
  id3 NUMBER
);
CREATE TABLE tmp_id_datetime (
  id1 NUMBER,
  date TIMESTAMP
);
```

При этом, эти таблицы существовали для всех пользователей, имеющих доступ к БД. Но данные, хранящиеся в этих таблицах, всегда были изолированы для каждого пользователя (т.е. пользователь А не мог увидеть данные в таблице tmp_id1, которые могли быть видны для пользователя Б). 
Данные в таблицах оставались в таблице и после того, как заканчивалась транзакция.

Ответь, пожалуйста, на следующие вопросы:
- Каким образом осуществляется подобное изолирование таблиц для конкретного пользователя в Oracle?
- В чём особое преимущество данного подхода к кэшированию данных внутри БД?
- Возможно ли осуществить подобное в PostgreSQL?


В Oracle для реализации подобного изолирования данных для конкретного пользователя используются временные таблицы, создаваемые в рамках сессии пользователя. Эти таблицы доступны только для конкретного пользователя и удаляются после завершения сессии. При этом данные в этих таблицах остаются после завершения транзакции.

Основное преимущество данного подхода к кэшированию данных внутри БД заключается в ускорении доступа к данным за счет уменьшения нагрузки на сеть и сервер при обращении к БД. Кроме того, это позволяет более эффективно использовать ресурсы БД, так как данные могут быть кэшированы внутри БД и не загружаться с диска каждый раз при обращении к ним.

В PostgreSQL также есть возможность создания временных таблиц, которые могут быть доступны только для конкретной сессии пользователя. Однако, по умолчанию данные в этих таблицах удаляются после завершения транзакции. Для того чтобы сохранить данные во временных таблицах после завершения транзакции, необходимо использовать ключевое слово "ON COMMIT" при создании таблицы. Например:

```SQL
CREATE TEMP TABLE tmp_id1 (
  id1 INTEGER
) ON COMMIT PRESERVE ROWS;
```

Также в PostgreSQL есть возможность использования схем, которые могут быть доступны только для конкретных пользователей или групп пользователей. В этом случае можно создать отдельную схему для каждого пользователя, в которой будут храниться его данные. Однако, это требует более сложной настройки БД и может быть менее эффективно, чем использование временных таблиц.

-----

В контексте предыдущего вопроса ответь, пожалуйста, на следующие вопросы:
- Что такое сессия в БД? 
- Если мы работаем с БД из клиентского приложения, то каким образом можно закрывать транзакцию/соединение, но при этом не закрывать сессию?
- Представим ситуацию: пользователь из UI клиентского приложения обратился к БД, сохранил данные во временную таблицу, которая определена в рамках сессии, а потом через 5 минут попробовал прочитать данные из этой временной таблицы. Сможет ли пользователь увидеть те данные, которые были сохранены во временной таблице? 
- Чем сессия в БД отличается от соединения к БД?
- Чем сессия отличается от транзакции в БД?
- Чем соединение к БД отличается от транзакци в БД?
- Когда будет удалена таблица в PostgreSQL, если её создать с помощью команды CREATE TEMP TABLE?
- Что означает команда ON COMMIT PRESERVE ROWS?
- Если использовать схемы для конкретных пользователей или групп пользователей в PostgreSQL, то какие ограничения могут быть по количеству ползователей (групп пользователей), для которых будут выделены отдельные схемы?
- Представим ситуацию: мы начали использовать постоянную таблицу вместо временной, но при этом добавили несколько столбцов (в частности, стали хранить ИД пользователя или группы пользователей, чтобы кэшированные данные были для каждого пользователя свои). Перечисли, пожалуйста, плюсы и минусы нового подхода к кэшированию данных.
- Можно ли в PostgreSQL поставить ограничение на чтение определённых записей для пользователей (например, пользователь А видит одни только свои данные, пользователь Б видит только свои, а админ БД видит данные всех пользователей)?


1. Сессия в БД - это период времени, в течение которого пользователь подключен к БД и выполняет запросы. Сессия начинается с подключения к БД и заканчивается отключением.

2. Для закрытия транзакции/соединения, но при этом не закрывания сессии, необходимо использовать методы, предоставляемые клиентским приложением для управления соединением с БД. Например, в .NET Framework для работы с SQL Server можно использовать объект SqlConnection, который позволяет открыть соединение с БД, выполнить запросы и закрыть соединение, не закрывая при этом сессию.

3. Если пользователь обратился к БД из той же сессии, в которой была создана временная таблица, то он сможет увидеть данные, сохраненные в этой таблице. Если же пользователь обратится к БД из другой сессии, то он не сможет увидеть данные из временной таблицы другого пользователя.

4. Сессия в БД отличается от соединения тем, что соединение - это физическое подключение к БД, а сессия - это логическое соединение, которое устанавливается между пользователем и БД на основе соединения.

5. Сессия отличается от транзакции тем, что транзакция - это логически связанная группа операций с БД, которая может быть зафиксирована или отменена как единое целое. Сессия же - это период времени, в течение которого пользователь подключен к БД и выполняет запросы.

6. Соединение к БД отличается от транзакции тем, что соединение - это физическое подключение к БД, а транзакция - это логически связанная группа операций с БД.

7. Если таблица создана с помощью команды CREATE TEMP TABLE, то она будет удалена после завершения сессии пользователя.

8. Команда ON COMMIT PRESERVE ROWS означает, что данные во временной таблице будут сохранены после завершения транзакции.

9. В PostgreSQL для каждого пользователя можно создать отдельную схему. Ограничений на количество пользователей или групп пользователей, для которых будут выделены отдельные схемы, нет.

10. Плюсы нового подхода к кэшированию данных: данные доступны для пользователя в любой момент, не зависимо от времени жизни сессии; возможность использовать индексы и другие оптимизации для ускорения доступа к данным. Минусы: увеличение размера БД из-за хранения дублирующихся данных; необходимость обновлять данные в кэше при изменении данных в основной таблице.

11. В PostgreSQL можно использовать механизмы RBAC (Role-Based Access Control) для установки ограничений на чтение определенных записей для пользователей. Например, можно создать отдельную роль для каждого пользователя или группы пользователей и установить ограничения на чтение данных для этой роли.
