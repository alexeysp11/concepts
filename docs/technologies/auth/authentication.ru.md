# authentication

## Хранение паролей

Подходы к хранению паролей:
- Обычный текст:
     - Хранение паролей в виде строки [обычного текста](https://en.wikipedia.org/wiki/Plain_text) является плохая идея, поскольку, если злоумышленник получит доступ к базе данных, он автоматически получит доступ ко всем учетным записям пользователей.
- Хеширование:
     - [Хеш-функция](https://en.wikipedia.org/wiki/Hash_function) позволяет сопоставлять данные произвольного размера со значениями фиксированного размера, что упрощает верификацию целостности данных.
     — Проблема в том, что 20% пользователей имеют один из 5000 наиболее часто используемых паролей, поэтому злоумышленник может применить функцию хеширования к этим паролям и получить доступ к 20% тех учетных записей, чьи пароли встречаются в украденном наборе данных.
- Перемешивание + соль:
     - [Соль](https://en.wikipedia.org/wiki/Salt_(cryptography)) — это случайные данные, подаваемые в качестве дополнительных входных данных в хеш-функцию.
     — В простейшем примере соль может быть одинаковой для всех пользователей, однако общесистемная соль позволяет злоумышленнику использовать хеш-таблицы для кражи паролей и компрометации учетных записей.
     - Соль может генерироваться для каждого пользователя отдельно (в зависимости от некоторых данных пользователя):
         - например, когда соль генерируется с использованием основной информации пользователя (*логин*, *имя пользователя*, *электронная почта*, *дата рождения*, *дата-время смены пароля*) - когда пользователь меняет свои данные, у него ввести свой пароль для регенерации соли и обновления хешированного пароля.

## Отправка паролей

- [Аутентификация "запрос-ответ"](https://en.wikipedia.org/wiki/Challenge%E2%80%93response_authentication) — это семейство протоколов, в которых одна сторона задает вопрос ("запрос"), а другая сторона должна предоставить действительный ответ ("ответ") для аутентификации.
- Простейшим примером протокола запрос-ответ является аутентификация по паролю, при которой запрос запрашивает пароль, а действительным ответом является правильный пароль.
- Более сложный пример может включать следующие шаги:
     - клиент отправляет логин и получает "вызов" от сервера.
     - клиент хеширует пароль ("вызов" может быть солью) и отправляет его на сервер.
- Чтобы улучшить протокол, сервер может отправлять несколько «запросов», чтобы клиент мог выбрать, какой из них использовать. Такой подход сводит к минимуму риск компрометации пароля.

## Защита от взлома

- Ограничение количества запросов: количество попыток пароля в секунду/минуту/часы.
- Тайм-ауты: минимальная продолжительность времени между двумя подборами пароля.

## Восстановление пароля

**Надежность пароля** можно определить как минимальное значение **его энтропии** (насколько сложно предсказать пароль) и **его энтории восстановления** (насколько сложно восстановить пароль), поскольку злоумышленник мог получить доступ к учетной записи, не только зная сам пароль, но и восстановив его.
```
strength = min(pswd_entropy, recovery_entropy)
```

## Многофакторная аутентификация

Многофакторная аутентификация должна использовать разные механизмы:
- Что-то, что пользователь знает (например, пароль).
- Что-то, чем пользователь владеет (например, телефон, смарт-карта).
     - Пользователь может получить код подтверждения по SMS.
- Что-то, чем пользователь являетеся (например, биометрия).
     - Вы можете запомнить устройства пользователя или геолокацию.

ВНИМАНИЕ: некоторые исследования показывают, что, побуждая пользователей выбирать многофакторную аутентификацию, они склонны выбирать более слабые пароли.
